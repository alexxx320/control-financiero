import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Transaccion, TransaccionDocument } from './schemas/transaccion.schema';
import { CreateTransaccionDto, UpdateTransaccionDto, FiltroTransaccionesDto } from '@/common/dto/transaccion.dto';
import { FondosService } from '../fondos/fondos.service';

@Injectable()
export class TransaccionesServiceFixed {
  constructor(
    @InjectModel(Transaccion.name) private transaccionModel: Model<TransaccionDocument>,
    private fondosService: FondosService,
  ) {}

  async create(createTransaccionDto: CreateTransaccionDto, usuarioId: string): Promise<Transaccion> {
    console.log('üí∞ CREAR TRANSACCI√ìN - VERSI√ìN CORREGIDA 2024');
    
    // Verificar que el fondo existe y pertenece al usuario
    const fondo = await this.fondosService.findOne(createTransaccionDto.fondoId, usuarioId);

    // ACTUALIZAR EL SALDO DEL FONDO
    await this.fondosService.actualizarSaldo(
      createTransaccionDto.fondoId, 
      createTransaccionDto.tipo, 
      createTransaccionDto.monto, 
      usuarioId
    );

    const nuevaTransaccion = new this.transaccionModel({
      ...createTransaccionDto,
      usuarioId: new Types.ObjectId(usuarioId),
      fondoId: new Types.ObjectId(createTransaccionDto.fondoId),
      fecha: new Date(),
    });

    return await nuevaTransaccion.save();
  }

  async findAll(usuarioId: string, filtros: FiltroTransaccionesDto = {}): Promise<{
    transacciones: Transaccion[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const {
      tipo,
      categoria,
      fechaInicio,
      fechaFin,
      montoMin,
      montoMax,
      page = 1,
      limit = 10,
      pagina,
      limite
    } = filtros;

    const pageNum = page || pagina || 1;
    const limitNum = limit || limite || 10;
    const filtrosConsulta: any = { usuarioId: new Types.ObjectId(usuarioId) };

    if (tipo) filtrosConsulta.tipo = tipo;
    if (categoria) filtrosConsulta.categoria = categoria;
    
    if (fechaInicio || fechaFin) {
      filtrosConsulta.fecha = {};
      if (fechaInicio) filtrosConsulta.fecha.$gte = new Date(fechaInicio);
      if (fechaFin) filtrosConsulta.fecha.$lte = new Date(fechaFin);
    }

    if (montoMin !== undefined || montoMax !== undefined) {
      filtrosConsulta.monto = {};
      if (montoMin !== undefined) filtrosConsulta.monto.$gte = montoMin;
      if (montoMax !== undefined) filtrosConsulta.monto.$lte = montoMax;
    }

    const skip = (pageNum - 1) * limitNum;
    const [transacciones, total] = await Promise.all([
      this.transaccionModel
        .find(filtrosConsulta)
        .populate({ path: 'fondoId', select: 'nombre tipo descripcion', strictPopulate: false })
        .sort({ fecha: -1 })
        .skip(skip)
        .limit(limitNum)
        .exec(),
      this.transaccionModel.countDocuments(filtrosConsulta),
    ]);

    return {
      transacciones,
      total,
      page: pageNum,
      totalPages: Math.ceil(total / limitNum),
    };
  }

  async findByFondo(fondoId: string, usuarioId: string, filtros: FiltroTransaccionesDto = {}): Promise<Transaccion[]> {
    await this.fondosService.findOne(fondoId, usuarioId);
    const filtrosConsulta: any = { 
      fondoId: new Types.ObjectId(fondoId),
      usuarioId: new Types.ObjectId(usuarioId)
    };

    if (filtros.tipo) filtrosConsulta.tipo = filtros.tipo;
    if (filtros.categoria) filtrosConsulta.categoria = filtros.categoria;
    
    if (filtros.fechaInicio || filtros.fechaFin) {
      filtrosConsulta.fecha = {};
      if (filtros.fechaInicio) filtrosConsulta.fecha.$gte = new Date(filtros.fechaInicio);
      if (filtros.fechaFin) filtrosConsulta.fecha.$lte = new Date(filtros.fechaFin);
    }

    return await this.transaccionModel.find(filtrosConsulta).sort({ fecha: -1 }).exec();
  }

  async findOne(id: string, usuarioId: string): Promise<Transaccion> {
    const transaccion = await this.transaccionModel
      .findOne({ _id: id, usuarioId: new Types.ObjectId(usuarioId) })
      .populate('fondoId', 'nombre tipo')
      .exec();
    
    if (!transaccion) {
      throw new NotFoundException(`Transacci√≥n con ID "${id}" no encontrada`);
    }
    
    return transaccion;
  }

  async update(id: string, updateTransaccionDto: UpdateTransaccionDto, usuarioId: string): Promise<Transaccion> {
    console.log('üîÑ EDITAR TRANSACCI√ìN - VERSI√ìN CORREGIDA 2024', updateTransaccionDto);
    
    // 1. Obtener la transacci√≥n original
    const transaccionOriginal = await this.findOne(id, usuarioId);
    console.log('üìã Original:', { tipo: transaccionOriginal.tipo, monto: transaccionOriginal.monto });
    
    // 2. REVERTIR el efecto de la transacci√≥n original
    const tipoOriginalInverso = transaccionOriginal.tipo === 'ingreso' ? 'gasto' : 'ingreso';
    console.log('üîÑ Revirtiendo:', tipoOriginalInverso, transaccionOriginal.monto);
    await this.fondosService.actualizarSaldo(
      transaccionOriginal.fondoId.toString(),
      tipoOriginalInverso,
      transaccionOriginal.monto,
      usuarioId
    );
    
    // 3. Determinar los nuevos valores - CORRECCI√ìN CR√çTICA
    const nuevoTipo = updateTransaccionDto.tipo || transaccionOriginal.tipo;
    const nuevoMonto = updateTransaccionDto.monto !== undefined ? updateTransaccionDto.monto : transaccionOriginal.monto;
    const nuevoFondoId = updateTransaccionDto.fondoId || transaccionOriginal.fondoId.toString();
    
    console.log('üìä Aplicando:', { nuevoTipo, nuevoMonto });
    
    // 4. APLICAR el nuevo efecto
    await this.fondosService.actualizarSaldo(nuevoFondoId, nuevoTipo, nuevoMonto, usuarioId);

    // 5. Actualizar la transacci√≥n
    const transaccionActualizada = await this.transaccionModel
      .findOneAndUpdate(
        { _id: id, usuarioId: new Types.ObjectId(usuarioId) },
        updateTransaccionDto, 
        { new: true }
      )
      .populate('fondoId', 'nombre tipo')
      .exec();

    console.log('‚úÖ SALDO DEL FONDO ACTUALIZADO CORRECTAMENTE');
    return transaccionActualizada;
  }

  async remove(id: string, usuarioId: string): Promise<void> {
    console.log('üóëÔ∏è ELIMINAR TRANSACCI√ìN - VERSI√ìN CORREGIDA 2024');
    
    // 1. Obtener la transacci√≥n antes de eliminarla
    const transaccion = await this.findOne(id, usuarioId);
    console.log('üìã Eliminando:', { tipo: transaccion.tipo, monto: transaccion.monto });
    
    // 2. REVERTIR el efecto en el saldo del fondo
    const tipoInverso = transaccion.tipo === 'ingreso' ? 'gasto' : 'ingreso';
    console.log('üîÑ Revirtiendo:', tipoInverso, transaccion.monto);
    await this.fondosService.actualizarSaldo(
      transaccion.fondoId.toString(),
      tipoInverso,
      transaccion.monto,
      usuarioId
    );
    
    // 3. Eliminar la transacci√≥n
    await this.transaccionModel.findOneAndDelete({
      _id: id,
      usuarioId: new Types.ObjectId(usuarioId)
    }).exec();
    
    console.log('‚úÖ SALDO DEL FONDO REVERTIDO CORRECTAMENTE');
  }

  async getEstadisticasPorCategoria(fondoId?: string): Promise<Array<{
    categoria: string;
    total: number;
    cantidad: number;
    promedio: number;
  }>> {
    const filtros: any = {};
    if (fondoId) {
      filtros.fondoId = new Types.ObjectId(fondoId);
    }

    const estadisticas = await this.transaccionModel.aggregate([
      { $match: filtros },
      {
        $group: {
          _id: '$categoria',
          total: { $sum: '$monto' },
          cantidad: { $sum: 1 },
          promedio: { $avg: '$monto' },
        },
      },
      {
        $project: {
          categoria: '$_id',
          total: 1,
          cantidad: 1,
          promedio: { $round: ['$promedio', 2] },
          _id: 0,
        },
      },
      { $sort: { total: -1 } },
    ]);

    return estadisticas;
  }

  async getResumenMensual(a√±o: number, mes: number, fondoId?: string): Promise<{
    ingresos: number;
    gastos: number;
    balance: number;
    transacciones: number;
  }> {
    const fechaInicio = new Date(a√±o, mes - 1, 1);
    const fechaFin = new Date(a√±o, mes, 0, 23, 59, 59);

    const filtros: any = {
      fecha: { $gte: fechaInicio, $lte: fechaFin }
    };

    if (fondoId) {
      filtros.fondoId = new Types.ObjectId(fondoId);
    }

    const resumen = await this.transaccionModel.aggregate([
      { $match: filtros },
      {
        $group: {
          _id: null,
          ingresos: {
            $sum: {
              $cond: [{ $eq: ['$tipo', 'ingreso'] }, '$monto', 0]
            }
          },
          gastos: {
            $sum: {
              $cond: [{ $eq: ['$tipo', 'gasto'] }, '$monto', 0]
            }
          },
          transacciones: { $sum: 1 },
        },
      },
      {
        $project: {
          ingresos: 1,
          gastos: 1,
          balance: { $subtract: ['$ingresos', '$gastos'] },
          transacciones: 1,
          _id: 0,
        },
      },
    ]);

    return resumen[0] || { ingresos: 0, gastos: 0, balance: 0, transacciones: 0 };
  }
}

// ALIAS PARA COMPATIBILIDAD
export const TransaccionesService = TransaccionesServiceFixed;
